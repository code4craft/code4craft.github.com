<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[代码工匠]]></title>
  <link href="http://code4craft.github.com/atom.xml" rel="self"/>
  <link href="http://code4craft.github.com/"/>
  <updated>2015-03-20T10:37:29+08:00</updated>
  <id>http://code4craft.github.com/</id>
  <author>
    <name><![CDATA[code4craft]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于代码质量的一些思考]]></title>
    <link href="http://code4craft.github.com/blog/2015/03/20/guan-yu-dai-ma-zhi-liang-de-yi-xie-si-kao/"/>
    <updated>2015-03-20T10:27:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2015/03/20/guan-yu-dai-ma-zhi-liang-de-yi-xie-si-kao</id>
    <content type="html"><![CDATA[<p>今天刚好看到同事写一段代码，跟同事聊到一个代码风格的问题，讨论了一会，也没得出什么结果。回来想了想，之所以大家观点不一样，其实是一开始代码追求的目的就不一样。</p>

<h2>1. 可读性</h2>

<p>我是一直认为代码的可读性是最重要的目标。太多的书都讲到一个观点：“代码是写给人阅读的，只不过刚好能被计算机执行”。</p>

<p>大部分做自己产品的团队，一个项目的维护时间可能是开发时间的5倍以上，而维护的常见内容都是一些小功能以及已有bug的修复。可读性带来的好处就是，非常容易弄清一段功能逻辑，从而定位问题。遇到团队人员变动，新人也能很快的熟悉。我在公司换过很多组，也接手过很多的项目（大多数的可读性并不好），就这一点来说，真是切肤之痛。</p>

<p>什么样的代码，算是可读性好？我跟别人提过一个标准：“你写的代码，过了几个月、半年、一年，跟你说道一个功能，即使你不记得这个功能怎么做，你也能说清楚这个功能写在哪个地方”。这个标准我自己认为还是很有效的。</p>

<p>那用什么方法可以增加可读性呢？合理的拆分和抽象会增加可读性。另外，我其实一直崇尚“用最常用的方法写程序，直到它发展到你已经理解困难的时候，再去重构”。</p>

<!--more-->


<h2>2. 代码美学与合理性</h2>

<p>经历过跟很多人的合作，我发现，很多非常优秀的开发者，会从直觉上把一个代码片段“是否优美”作为第一考虑的目标。他们会追求一些高级编程技巧的合理运用，或者开发一些公共组件，来达到行数足够少，或是表达足够清晰的目标。这个好像教材里也不曾提到的，我把它叫做“合理的代码美学”。</p>

<p>对于Java代码来说，有人就喜欢把一些常见功能，用自定义注解，然后用AOP来完成注解的解释。例如，一个功能需要随时可以打开或关闭，我可以通过一个注解来完成它而不是在业务处理中写一些if-else-check。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@NewFeatureEnabled</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">(){</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上，完成一个“优美的”小功能，也就是用自己心中认为最好的方法去完成一件事，这样的满足感，也是让人持续编程的动力。严格的说，这样的代码有没有给代码质量带来提升呢？肯定有。第一很多时候这样的代码会经过更多的考虑，必然有更高的质量；第二很多更好的开发技巧，都是来自这些“不一样”的追求。</p>

<p>但是我认为，软件开发与艺术最大的不同是，它是一个多人合作劳动，一个人觉得合理的，其他人未必会感同身受，甚至会恰恰相反。这样的代码是蛋糕上华丽的三层奶油，有时会给人眼前一亮的感觉，但是也可能会让人找不到蛋糕本身。所以我的建议是：“如果你要用一个新技巧，最好积极宣传，和团队达成共识”。</p>

<p>比如这个<code>@NewFeatureEnabled</code>的功能，我会想：“如果别人接手这个项目，他是不是知道NewFeatureEnabled是什么意思？即使知道，他怎么知道这个功能的开关，是由其他地方一个AOP来完成的呢？”但是如果大家都接受这个方式，知道AOP是在哪里配置，如何工作的，那么也就是一个还不错的尝试了。</p>

<h2>3. 可复用性</h2>

<p>追求复用性是开发者的一个本能。大家都希望少写代码，最好要用的时候，一切都准备好了。我见过太多的代码为了复用而设计，但是基本上所有以复用为第一目标的代码，都没有什么好质量。为了复用的抽象，常见的就是把一段公用的代码块独立出来成为函数或者类，而这部分的逻辑甚至都是无法独立存在，也单独无法被人理解的。</p>

<p>我不是说可复用性不重要，但是它确实容易让人走上歪路。比较好的复用方式，应该是零件式的复用，每一块都有各自的规范和存在，但是这样的复用是一个严肃的过程，往往也达不到最大化的“代码复用”；比较差的方式是拼接式的复用，类似于为了表示一只猫和一只狗，把猫的身体和狗的身体复用成一块，然后写一堆判断代码来告诉别人什么时候这个身体是猫，什么时候这个身体是狗，最后再跟各自的脑袋组合起来。当然了，没有人知道这个“既是猫又是狗的身体”是什么。如果你想知道猫长什么样，估计得把半个项目都看完了。</p>

<p>如果一个项目以这样的思路开发久了，你会发现代码逻辑散落在各处，各种业务场景互相交织，任何改动都会牵一发动全身。</p>

<p>如果要为可读性排个名的话，我认为大概是：</p>

<p>毫无头绪的抽象&lt;只为复用的抽象&lt;不做抽象&lt;简单的抽象&lt;局部优美的代码&lt;整体优美的代码&lt;清晰的层次结构并抽象&lt;整体优美并且被大家接受的代码</p>

<p>最后一个层级，这样的代码实际上已经是更高的生产力了，就像Spring之于满地new对象就是个进步。可能代码进化到最后，真的就是跟自然语言那么简单，到时候我们就需要研究怎么在代码里写诗了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写在29岁的最后]]></title>
    <link href="http://code4craft.github.com/blog/2014/12/29/xie-zai-29sui-de-zui-hou/"/>
    <updated>2014-12-29T23:23:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/12/29/xie-zai-29sui-de-zui-hou</id>
    <content type="html"><![CDATA[<p>女儿和老婆已经睡觉了，小家伙乖得很，最近已经会大声的叫爸爸了，好不可爱。最近一直没心思写文章，在14年的最后，还是写一点东西吧。</p>

<!--more-->


<p>本来14年总结已经写了，但是心里还是有些不安定。不安定主要来自几个因素：一是过了年，明年就30岁了，而立之年，却觉得自己没有而立的迹象；二是昨天听一个创业的朋友讲到她的经历，对比自己打工的安稳生活，有一些触动；三是最近看了几篇文章，大致是讲工作和个人发展的关系，讲到工作未必能带给你一切。</p>

<p>于是心里有些不淡定。未必一定要做什么，但是整理一下思路，发散一下思维，总归会让自己安心一点。</p>

<p>生活上走的平稳，结婚、买房、生孩，比起在大城市的同龄人来说，可能已经算是走的很快了。家庭幸福，经济上也算是过得去，没什么可挑剔的。</p>

<p>工作上也是走的平稳。三年工作经历，在的公司大众点评也算是上海互联网知名企业，目前是可以独当一面的一线开发。就工作三年来说，完全是靠自己稳扎稳打，提高速度还算是比较快的。但是因为毕业比较晚，所以年龄跟身边的一线开发比起来算比较大了。</p>

<p>关于工作，我觉得有两点还是比较重要的：</p>

<h3>1. 关于自我认识</h3>

<p>年龄大了最怕同学会，怕看到大家各自混得多好多好之类的。其实我觉得到了而立之年，未必是要事业小成，毕竟人的事业还有好多年可发展。更重要的是自己的思想要形成了，要知道自己要追求的是什么，不再因为别人的评价而改变自己的目标了。</p>

<p>我之前其实想过很多目标，比如最开始觉得要多掌握技术，多学习东西，输出技术影响力，所以写了WebMagic，又写了很多博客；后来又由于岗位重要性增加，逐渐又往公司业务发展，想要用技术产生更大的价值。这些其实都是很简单的技术人员的目标，用技术影响更多人。现在想起来，也只有为这个目标在奋斗的时候，才会觉得最充实、最快乐。</p>

<h3>2. 关于职业发展</h3>

<p>年中的时候调了一次薪，又因为一些家庭的压力，对经济的要求更加高了。因为公司的一些业务导向的方式，又让我似乎又“清晰的认识到了纯做技术的瓶颈”，不得不考虑到以后的职业发展的问题。</p>

<p>于是我回到了那个经典的“技术还是管理路线”的问题。有好一段时间，我一直在linkedin上翻各种人的简历。然后我发现一个现象：好多架构师出去了也能胜任总监、CTO的角色，而现在的总监、CTO也多是从基层技术做起，他们唯一的共同点就是：在这个技术和业务领域有很长的工作经历。</p>

<p>另外一个我看到的就是，其实技术职业发展相对扁平，有2到3次机会（有同一公司，也有跳槽），也就差不多了。对于自己来说，倒不如问自己，如果这样的机会来了，你是否能胜任，欠缺什么，更为重要。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014年总结]]></title>
    <link href="http://code4craft.github.com/blog/2014/12/22/2014nian-zong-jie/"/>
    <updated>2014-12-22T22:47:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/12/22/2014nian-zong-jie</id>
    <content type="html"><![CDATA[<p>又是一年年底。今年我跟老婆结婚第三年，女儿也有一岁半了，一切安好，有家人的陪伴真好。工作上，今年是工作第四年，有了更多的责任，也有了不少的突破。</p>

<!--more-->


<h2>1. 生活</h2>

<p>生活的重点都在小家伙上。小家伙很可爱，看着她一天一天长大，也觉得很开心。带小孩还是比较累的，现在每天下班之后都需要陪她到睡觉，早上起来还要带个把小时。</p>

<p>因为工资涨了一些，虽然有不少的房贷，但是也没有什么压力了。后来和老婆也定了一些理财计划，以后会慢慢的执行，让生活越来越好。</p>

<p>生活越来越平淡，平平淡淡才是真嘛。</p>

<h2>2. 工作成果</h2>

<p>今年工作中发生的事情还是比较多的。</p>

<p>一个是随着工作经验的积累和自己的表现还不错，也受到了更多的重视。参与了几个比较大的项目，也有不少是作为负责人参与，在小伙伴中的声望也比较高了。年中的时候做了一个大项目，整个部门30多个人封闭开发了2个多月，得到了不少锻炼，也作出了不错的成绩。</p>

<p>在做这个项目的同时，我也体会到了团队的重要，后面就更多的参与到团队建设中来。后面的半年，我组织了接近20次分享，目的是让大家都能得到提高。这也给我们团队起到了不少的推动作用。</p>

<p>业余上，写的博客数下降了，但是今年花了接近一个月时间，写了一个WebMagic的文档。这是个大工程。因为这个工作，WebMagic的推广更加的迅速，已经有了接近700个star，QQ群也突破了500人。</p>

<h2>3. 技术提高</h2>

<p>技术方面，也还是有一些收获的。主要是往上(架构设计)，往下(性能优化)。</p>

<p>一个是设计方面，随着经验的增加，分析问题也有了一些方法论，使得做设计更加有章可循。总体来说是进步。</p>

<p>关于性能优化方面。年前做了一次重构，重构对象是公司最重要、调用量最大的团单服务，重构的结果，无论从效率还是可用性上来说，基本上已经优化到了业务的极限，瓶颈反而到了RPC中间件、数据库、缓存等地方。我记得年初的目标是“能对性能做定量分析”，今年看来算是达到了50%。</p>

<p>实际上总结下来，我发现无论往上还是往下，详细的分析往往比方案要更有价值。这也算是成为了我的一种方法论吧。</p>

<p>其他的技术提高比较琐碎，也乏善可陈。确实今年变懒了。</p>

<p>年底换了组，做一些ERP性质的开发，挑战更小，必须要自我提高了。要有点危机感。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[追求的和得到的]]></title>
    <link href="http://code4craft.github.com/blog/2014/11/12/zhui-qiu-de-he-de-dao-de/"/>
    <updated>2014-11-12T23:31:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/11/12/zhui-qiu-de-he-de-dao-de</id>
    <content type="html"><![CDATA[<p>今天做了两个月的团单服务改造终于上线了，相比之前的服务，性能基本上提高了一个数量级，稳定性也增加不少。这是今年做的最有价值的一个项目，之前服务数次S1故障的场景历历在目。而这次重构是按照业务量增加几倍来设计的，相信再过一两年都不太会出问题了。</p>

<!--more-->


<p>这个项目的完成还是比较曲折的，中间人员组织调整了好几次。从开始连CEO都亲自过问，到最后连找人改个bug都很困难。最后我承担起了项目跟进的工作，说实话推进很困难，还好还是按时上线。就在今天完成的当天，就听说这些业务要交出去了。</p>

<p>交就交吧，KPI其实是个浮云，这个也不做多想了。无论怎样，只希望把事情做好，以后提到这件事的时候，还记得我的名字，也就够了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近几个月的总结]]></title>
    <link href="http://code4craft.github.com/blog/2014/11/01/zui-jin-ji-ge-yue-de-zong-jie/"/>
    <updated>2014-11-01T07:53:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/11/01/zui-jin-ji-ge-yue-de-zong-jie</id>
    <content type="html"><![CDATA[<p>从转部门开始，一晃已经半年过去了。这几个月可以说是非常充实的一个月，学会了很多技术以外的东西。但是相对的，除了项目经验增加了之外，技术方面的进步却比较少，特别是很少有业余时间来研究技术，写写博客了。我还是希望能达到一个更平衡的状态，所以先总结一下。</p>

<!--more-->


<h2>1.收获</h2>

<p>先说说收获吧。</p>

<p>这半年做了一些很大规模的项目。之前基本上是领导分配具体任务给我，完成就行了。现在变成了领导只提大致内容，需要自己去负责。所以这段时间，学会了如何和其他部门配合，如何评估任务时间，如何协调资源，如何培养新人。这些都是之前不曾接触过的。</p>

<p>我的理解这也算是管理的基本课程。虽然我并不喜欢管理，但是个人力量毕竟有限，有些东西确实需要团队作战，我的价值观是能够做成事情，所以与我的目标也并不相悖。</p>

<p>在做这些事情的时候，我也学到了一些东西。与技术不同的是，总结一下，这些经验好像跟公司文化有很大关系。相对来说，我觉得有两点算是比较通用和重要的。</p>

<ul>
<li><p>沟通到位</p>

<p>  一旦涉及到跨组甚至跨部门合作，沟通就会非常重要。一个是事情进度会变得不透明，二个是有些事情能不能做成，也不是自己能决定的了。第一个要及时沟通避免风险，第二个则是要让上面知道，到底瓶颈在哪里，是不是你的责任。很无奈的是，之前我是非常讨厌开会的人，现在却不得不体会到了开会的重要性。</p></li>
<li><p>要有靠谱的团队</p>

<p>  一个有战斗力的团队是非常重要的。之前做了几个时间很紧的项目，因为参与人都还不错，完成的很顺利。做技术的还是要避免“我最厉害，什么都能做”的想法，多多利用团队的力量。项目不忙的时候，多多给新人锻炼的机会，这样在重要的时候才能顶上。</p>

<p>  不过话说回来，人本身的素质和意愿其实也很重要，你只能提供一个成长的环境和机会，没有办法强迫别人成长。这段时间也参与了一些招聘，算是这方面也有些了解。在我看来，成长的意愿比技术实力更加重要，也难怪HR要强调“追求卓越”了。</p></li>
</ul>


<p>另外一个有意思的是，我学会了“设计要以人为本”。这个意思并不是要多么人性化，而是指设计项目要考虑组织结构、人员组成这些因素。这个一直想写个博客，以后有空整理一下来讲。</p>

<h2>2.不足</h2>

<p>这几个月技术上进步不算多。唯一比较有意思的是，接手了公司访问量和复杂度最大的一个服务，做了很多维护性的工作，对故障分析、JVM调优的知识有了很多进步。</p>

<p>至于业余时间，基本上没有什么提高。WebMagic有半年没更新了，这半年也没有系统的分析过什么项目，也没有完整的看过什么书。</p>

<p>先说说原因吧，主要还是工作上的。主要是杂事增加了，这些事情可以分几类：</p>

<ul>
<li>新部门是直接跟销售打交道，每天都会有很多问题需要技术处理。</li>
<li>手头负责的业务重要性提高，处理事务、与需求方沟通的时间增加。</li>
</ul>


<p>老实说，最开始出现这些事情的时候，我心情是比较开心的，好像自己是个“人物”了，每个问题也一一处理。后来事情越来越多，非常分散精力。导致一下班，什么都不想干，要么倒头就睡，要么看看电影，让大脑处于不工作的状态。</p>

<p>最近这段时间我开始控制这些事情了，第一类问题我们组也有了值日生，专门负责处理；第二类问题我也会缩短时间，指定优先级，最近也更多的使用TODO LIST这种东西来管理待办事项和优先级了。</p>

<p>再一个原因，我觉得是随着年龄的增长、眼界的增加，想要的东西更多，可用的时间却更少。这个东西是不是传说中的“技术人的中年危机”呢？今年我给自己定了很多技术方向，比如成为性能分析的专家，比如研究SOA的设计，比如学一门非计算机的学科，但是每件都做的不算满意。一个是对深度要求更高，另一个是时间有限。</p>

<p>我的经验是，一个目标，刚刚确定的一个月半个月是最有热情的，如果这个时候因为各种原因，没花够时间的话，以后也不太能继续下去了。今年有太多这样的例子了。想做的事情很多，还是一定要专注。</p>

<p>没了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[十一贵州行记]]></title>
    <link href="http://code4craft.github.com/blog/2014/10/07/guo-qing-gui-zhou-xing-ji/"/>
    <updated>2014-10-07T21:40:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/10/07/guo-qing-gui-zhou-xing-ji</id>
    <content type="html"><![CDATA[<p>十一陪老婆回贵州，住了几天。主要以陪老婆见亲戚和带宝宝为主，中间也有些见闻心得，记录如下。</p>

<!--more-->


<h2>关于二三线城市</h2>

<p>最开始的感受是贵州物价便宜，一顿饭30-40块钱已经是请客吃饭的水平了，在上海大概是一顿好一点的工作套餐。</p>

<p>硬件设施上，贵州一些市区的建设已经不输于上海周边的水平。比如我家住在上海外环边上，大概跟安顺市比较热闹的地段差不多。</p>

<p>但是服务质量上就相差甚远。在贵州很难打到出租车，拼车也已经成为一种惯例了，因为我们是四个人出行，基本没有司机愿意载，导致最后打到车都要对司机有一些感激之情。特别是从贵阳火车站出来那一段，全程人挤人，出租车点直接被人群挤满，但是因为交通阻塞，根本没有出租车过得来。相比在上海，火车站、飞机场的出租车点总是井然有序，在街边打车也很少拒载，也很少有司机想要拼车。</p>

<p>其实关于这种现象，我无意归结为素质问题，更愿意认为是地区文化和发展程度的问题。因为服务质量这种概念还没有成为习惯，大多数都还停留在满足基本的功能需要上。</p>

<h2>关于团购</h2>

<p>这次回家，让我惊讶的是我们的竞争对手美团的团购已经推广到六盘水市了，而点评则没有。跟几个朋友聊了一下，他们都算是还比较追随潮流的的年轻人，说都知道美团和大众点评，倒是团购都用美团，但是不知道点评还有团购业务。</p>

<p>团购在用户端就是电商，知名度、产品价格、丰富程度、用户体验、服务质量都决定了用户的选择。而且移动端用户一般不会同时对多个团购网站进行比较，于是很容易出现强者越强的现象。这一点点评在二三线城市失去了大部分机会，要扳回非常困难了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一次参加校招的心得]]></title>
    <link href="http://code4craft.github.com/blog/2014/09/24/di-yi-ci-can-jia-xiao-zhao-de-xin-de/"/>
    <updated>2014-09-24T22:43:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/09/24/di-yi-ci-can-jia-xiao-zhao-de-xin-de</id>
    <content type="html"><![CDATA[<p>这几天第一次参加了公司的校招面试，地点是南京。有意思的是，被安排做了测试的面试官。这里面有两层意思：第一是面测试的以妹子居多，对于我这种技术向宅男来说，基本超过了十年来说过话的妹子之和；第二是面测试的以非计算机专业的居多，没得聊只能聊研究方向了，于是我在这几天已经迅速掌握了“LTE-A在MIMO场景下预编码下w矩阵求逆的凸优化问题”。</p>

<p>这一次面试收获很多，总结如下。</p>

<!--more-->


<h2>1. 学生——走出象牙塔</h2>

<p>这次最大的感受就是又回到了毕业找工作那段时光，只不过角色换了一下。一晃过去已经4年了，总的来说，当年的我属于不善沟通、埋头做研究、对外界一无所知的那种。面试有过好几次碰壁。等到真正工作了，发现能力与公司的内容相去甚远，还好遇到了陈老师这样技术好且有耐心的的人带，当时拼命的做需求，慢慢的就跟上节奏了。</p>

<p>这次面试基本上都是研究生，做的内容都是高大上的研究，这种算法优化那种优化等等。说实在的，我在学校做过3年算法应用方面的研究，又在公司做了3年码农，感觉确实是做工程的门槛确实要低一点，所以那些研究做的好的学生无疑是比较聪明的。</p>

<p>但是反过来说，做这些研究能够提供的就业岗位确实有限，很多人还是要出来公司，做一些工程上的东西的。这个时候，对自己未来的职业发展有没有规划，可能是决定就业竞争力最重要的因素了。</p>

<p>这个准备无非就是几个方面：主动学习了工程相关的知识，业余做过几个小项目，最好还有过一两段实习经历。</p>

<p>其实现在开源社区已经足够成熟，如果做开发的话，通过接触和编写一些开源项目，是一个非常好的提升途径，效果基本上比在一些小公司做项目都要好。如果做测试的话(好吧我刚好面试的是测试)，可能途径会少一点，基本上只有在一定规模的公司，才能做出有效的实践。但是相对来说要求就会低一点(至少我面试的是这样)，掌握了了基本理论，已经算是比较不错了。</p>

<p>另外，有的面试官只会问到一些工程技能，会不会写SQL会不会Java之类，我觉得这也有些偏颇了。对于研究生，研究能力也是挺重要的。因为只做工程的人可能缺乏一些钻研的精神，而研究生这方面就会强一点。毕竟一个概念理解一个月也是常有的事，这在搞研究的时候属于才入门。这点时间已经可以读懂一个中等规模项目的源码了，这个在工程界水平已经比较高了。</p>

<h2>2. 公司——招聘和成本</h2>

<p>最开始的感受是，第一次感觉到了公司招聘的成本。几十个人什么事都不干跑来外地一住就是几天，而且这些人一般还都是专业比能力较强的，对公司日常业务发展影响其实挺大的。有些觉得不错的候选人，就因为面试官安排不过来，最后只能放弃了。</p>

<p>反映到自己身上就是一天从早面试到晚，强度非常大，第一天一共面试了15个。所以这种情况下面试随机性其实也挺大的，每次到了下午某点就觉得理解力显著下降。所以有些人考察的不仔细，也只能说是没办法了。结合自己当年的经历，好像也能够释然一点。</p>

<p>关于面试的环节、面试的内容，其实本来我之前写了很多东西。后来想想，当你确定了对候选人的期望之后，这些东西反而是不重要的了。比如你想知道他的研究水平，就看他能不能讲清自己研究的背景，是不是了解领域的现状、相关的外延技术，在具体描述一下研究的改进点，最后看看发的论文如何。比如想知道对于职业有没有规划，就看有没有看过类似的书、做过类似的项目、有过类似的实习经验。前面也说到，这两个再加一个基本的专业知识(数据结构、数据库、操作系统、网络、写代码)，差不多就是考察的全部内容了。</p>

<p>最后说说手写代码吧。受到陈皓老大的影响，我非常反感在面试中出纯算法题。这样的题目存在两极分化，大部分人不会做，做出来的基本上是背答案或者特别牛的。但是这个环节想考察的总归是一般性的能力。我借鉴了陈皓那篇文章中的关于atoi()的题目。实际效果上，这道题还是比较有区分度的。思维是否有逻辑、是否严密，编程习惯是否好，一下子就能看得出来。</p>

<p>顺便说一句，这次我负责初面，面试的结果还可以，通过的比例不小，而且这些人基本都过了复试。用分类模型来说，召回率和准确率都还可以，算是比较好的完成了任务。</p>

<h2>3. 一些后话</h2>

<p>絮絮叨叨这么多，不是想给谁谁什么指导，只是对自己这几天思路的一个总结。我其实反应比较慢，有些东西也是边做边学，但是希望还是通过这样的方式慢慢变得更厉害，发现更多优秀的学生。做好伯乐，善莫大焉。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java性能优化笔记]]></title>
    <link href="http://code4craft.github.com/blog/2014/09/13/javaxing-neng-you-hua-bi-ji/"/>
    <updated>2014-09-13T10:17:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/09/13/javaxing-neng-you-hua-bi-ji</id>
    <content type="html"><![CDATA[<p>最近在做一个关键性服务的重构，重构完之后需要做性能测试。期间一直也在看《Java性能优化权威指南》这本书，记得今年的目标是“能对Java性能做定量分析”，所以趁这个机会好好研究一下。</p>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[羊毛战争]]></title>
    <link href="http://code4craft.github.com/blog/2014/08/21/yang-mao-zhan-zheng/"/>
    <updated>2014-08-21T21:00:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/08/21/yang-mao-zhan-zheng</id>
    <content type="html"><![CDATA[<p>最近看《羊毛战争》，主角最开始是个技术宅，维护整个地下世界唯一的发电机。“你知不知道我负责的东西多么重要，没有它整个地堡都将陷入黑暗？”“但是我要你做的是更重要的事，没有了人，这些玩意也没有意义了是吧？”我觉得对技术宅的态度更加如是，技术重要，思考方向也是必要的。</p>

<!--more-->


<p>最近在做的几个项目也没什么技术含量，但是对公司来说还是满重要的，自己也从技术人慢慢转到技术管理。不管怎么说，先创造价值吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈技术在职业发展中的意义]]></title>
    <link href="http://code4craft.github.com/blog/2014/08/14/tan-tan-ji-zhu-zai-zhi-ye-fa-zhan-zhong-de-yi-yi/"/>
    <updated>2014-08-14T23:32:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/08/14/tan-tan-ji-zhu-zai-zhi-ye-fa-zhan-zhong-de-yi-yi</id>
    <content type="html"><![CDATA[<p>今天跟领导聊了一会天，收获很多，有些事情之前没想到的，现在又有了新的认识。</p>

<p>职业发展追求的是什么？无非是更高的职位，更高的薪水。更高的职位可以让你能做更多的事情，更高的薪水则是生活质量的保证。对于技术来说，也希望自己的产品能够影响更多的人。</p>

<!--more-->


<h3>技术不是技术人的一切</h3>

<p>之前一直混技术社区，向往的是技术大牛。</p>

<p>在geek的世界里，可能根本没有“职业发展”一说，他们成天钻研更酷的技术，活在自己的世界。知乎上有一篇帖子<a href="http://www.zhihu.com/question/24612523">《在北上广深一线城市年薪二十、三十、四十万的码农的真实生活状态是怎样的？》</a>，可以参考一下。</p>

<p>之前一直在纠结以后是管理路线还是技术路线，今天听到一段话，觉得特别有道理：“其实什么管理路线，技术路线，最终还就是看你这个团队在公司受不受重视”，说白了就是跟对人。其实软件开发本质上来说还是个工程内容，技术再好，没有项目，不能给公司提供价值，自然也没什么好的回报。</p>

<hr />

<h3>技术的意义是什么？</h3>

<p>在我看来，第一，是安身立命之本。职业发展不可能一帆风顺，但是技术水平过硬，至少可以保证生存不成问题。诺基亚的裁员就是个例子。我面试的时候见过所谓十几年经验的“项目经理”，技术水平一团糟，可能还不如一年两年的新人的水平，在逆境时真的是个悲剧了。</p>

<p>第二，技术过硬的领导，会更容易得到下属的支持和尊敬。注意我这里用了“尊敬”两个词，其实真的如此。虽然不是leader，但是最近也临时带了几个项目，尊敬级别谈不上，但是明显能感觉到大家还是比较配合的。我的一个支付宝来的同事，老是说起他们老大做的什么什么，确实推崇的很。</p>

<p>第三，技术太烂，确实会做不好事情。当然，这也不直接导致他混的好不好，混的好的大有人在。</p>

<p>第四，个人追求。</p>

<p>能想到的就这些了，我的意思倒不是说谁对谁错，但是没有目标，盲目的觉得技术至上，也不太可取。毕竟我也是一个俗人，上有老下有小，职业发展也是不得不考虑的事情了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[细节之美]]></title>
    <link href="http://code4craft.github.com/blog/2014/08/12/xi-jie-zhi-mei/"/>
    <updated>2014-08-12T23:05:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/08/12/xi-jie-zhi-mei</id>
    <content type="html"><![CDATA[<p>最近一个大项目忙完，今天领导召集大家，又要重新做另外一个项目，本质上就是要把之前的业务重写一遍。</p>

<!--more-->


<p>站在领导的角度来说，看重的是“拉大旗好办事”，大项目相对来说好拉资源，小伙伴们也能得到锻炼，对于团队来说绝对有利，无可厚非。</p>

<p>但是从纯技术的角度来说，好的项目是需要打磨的，无论是设计还是实现层面，都是一个迭代的过程。webmagic断断续续维护了一年了，好像现在也有很多同类的框架出现，我觉得webmagic最有竞争力的方面，不是单纯的架构设计有多好，而是github上100多个issue。</p>

<p>一个好的项目，优秀的设计占比30%，那么后续维护和完善基本上要占据70%的比例，这是我的观点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[缓存使用中的抽象泄露问题]]></title>
    <link href="http://code4craft.github.com/blog/2014/07/28/huan-cun-shi-yong-zhong-de-chou-xiang-xie-lu-wen-ti/"/>
    <updated>2014-07-28T09:37:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/07/28/huan-cun-shi-yong-zhong-de-chou-xiang-xie-lu-wen-ti</id>
    <content type="html"><![CDATA[<p>最近做的业务遇到一个比较棘手的问题：有一个比较核心的数据获取服务，因为其数据库比较分散，从数据库读取效率很低，于是需要使用缓存来解决问题。</p>

<!--more-->


<p>这个业务是非常依赖缓存的，现在就遇到一个问题：大部分请求都能让缓存工作的很好，但是少量请求会导致缓存的大量失效。</p>

<p>举个例子，现在做一个博客类网站，那么将博客文章缓存起来，因为大部分文章都满足访问热点，所以并没有太多问题。但是如果有一个服务，需要获取某个博主历史的所有文章，或者获取某个人收藏的所有文章，这个时候缓存就不太管用了。</p>

<p>了解了一些缓存淘汰算法，例如LRU、FIFO、LFU，以及LIRS等。但是无论任何算法都是依赖局部性原理(<a href="http://en.wikipedia.org/wiki/Locality_of_reference">Locality of reference</a>)的。局部性显然是根据使用场景不同而不同的。</p>

<p>而实际情况下，我们倾向于把缓存和数据库一起作为数据访问层，这种抽象对上层使用很友好，但是在场景增多、量级增大的时候，很可能出现问题。我的理解这就是缓存使用中的抽象泄露问题。</p>

<p>关于博客这个例子，比较合适的方式是用LFU代替LRU，但是依然会有些其他问题。写记录下来吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写在工作满三年的时候]]></title>
    <link href="http://code4craft.github.com/blog/2014/07/24/xie-zai-gong-zuo-man-san-nian-de-shi-hou/"/>
    <updated>2014-07-24T21:54:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/07/24/xie-zai-gong-zuo-man-san-nian-de-shi-hou</id>
    <content type="html"><![CDATA[<p>连续忙了大概1个半月，没有9点之前回家过，今天项目终于临近尾声，回家写个博客吧。</p>

<p>转眼间工作满三年了。</p>

<!--more-->


<h2>1.生活</h2>

<p>三年前我怀揣着梦想来到了北京，后来又为了家庭来了上海。在北京的一年，没有家庭负担，和女朋友过着甜蜜的日子，工作虽然忙但是没什么压力，整天玩玩游戏，玩玩摄影，非常自在。工资其实挺低的，但是两个人在北京，一个小单间，已经觉得很开心了。</p>

<p>来了上海之后，组建了家庭，随后有了宝宝，过上了有责任的生活。生活上基本都围着小家伙转了，失去了一些乐趣，也得到了一些乐趣。或许这就是人生吧。以后需要投更多的时间在生活上。</p>

<h2>2.工作</h2>

<p>论工作状态，其实没有发生什么变化，因为技术总归是喜欢的事情，无论做什么都能找到乐趣。闲的时候就做技术钻研，研究开源技术，也搞出了webmagic这个不错的项目，也提交过几个著名项目的patch。忙的时候除了完成任务，也会探索一些工具化的方式，提高效率，也能从工作中积累一些实践经验。</p>

<p>工作三年了，因为对技术比较专注，也成了一些新人小伙伴学习的对象。而之前更多是作为一个新人来看待自己，这一点倒是需要调整了。</p>

<p>例如最近做的一个大项目，学到了很多东西。变化最大的是，因为带了几个新人，从之前单打独斗的方式，开始学会安排任务，利用大家的力量。其中感受比较深的就是，要学会合作，既要给能力不足的同事及时的支援，也要给新人合适的锻炼机会。可能确实上手的时候有一段适应期，但是一旦上手起到的作用，可能会超过你的预期。</p>

<p>一个连Java类和接口都分不清的实习生，在指导了大概一两天之后，也能独立的开发出MVC结构的一个完整功能了。所以即使是考虑到项目紧张，也不要只安排最没有技术含量的工作给他们。</p>

<p>也有工作两年的同学，因为之前没做过相关业务，所以迟迟动不了手的，这些给他们指明道路之后，也能够很快的跟上。</p>

<p>这一点我前期做的不好。一个项目7个人，我大概写了50%以上的代码，其中包括全部框架性质的内容，大致留给他们的是一些接口的实现工作。最后的结果就是开发完成的很快，但是后期修改需求都堆积在我这里，导致进度缓慢。于是今天决定停下项目，把手头做的东西好好讲一讲，让大家能够参与进来。事实证明这个方法效果很好，大家基本上能够分担很多任务了。</p>

<p>工作满三年，已经过了急着要证明自己的时候了。带领团队的成长，才是更需要做的事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安安满岁了]]></title>
    <link href="http://code4craft.github.com/blog/2014/07/21/an-an-man-sui-liao/"/>
    <updated>2014-07-21T23:59:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/07/21/an-an-man-sui-liao</id>
    <content type="html"><![CDATA[<p>今天安安满岁了，我却还在公司加班，都没有能见她一面。相信付出总会有回报，能力加上努力，一定会让家里变得越来越好！</p>

<p>爸爸也好喜欢安安啊！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码大全读书笔记]]></title>
    <link href="http://code4craft.github.com/blog/2014/07/01/dai-ma-da-quan-du-shu-bi-ji/"/>
    <updated>2014-07-01T23:01:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/07/01/dai-ma-da-quan-du-shu-bi-ji</id>
    <content type="html"><![CDATA[<p>最近项目开发比较密集，也遇到了一些方式的碰撞，这个时候再翻到《代码大全》，真是瞌睡时碰到枕头的感觉了。决定好好读一遍，记录一下。</p>

<!--more-->


<p>xxiv: 软件构建是项目必须完成的阶段，它要为小型项目75%的错误负责，为大型和中型项目50%-75%的错误负责。——我们在项目的错误中，往往只看重设计的重要性，其实大部分错误都来自软件构建（即编程）本身。</p>

<p>P11：如何利用隐喻Metaphors（对软件的建模），将影响如何解决这个问题。</p>

<p>P28：程序员是软件食物链的最后一环。架构师吃掉需求，设计师吃掉架构，而程序员则消化设计。</p>

<p>P35：前期做好准备的项目，返工的成本是最低的。如果无法做到完全的准备，准备80%的需求，并为20%留够时间是一个可行的做法。</p>

<p>P46：架构应该确定软件采用的组织结构，并尽量列举其他可能的方案以及选择最终方案的理由。依据80/20原则，架构可以对确定决定项目80%功能的20%的类进行详细说明。</p>

<p>架构设计的常规内容(挑几个觉得重要的)：</p>

<ol>
<li>程序组织 Program Orgnization</li>
<li>主要的类 Major Classes</li>
<li>数据设计 Data Design</li>
<li>业务规则 Business Rules</li>
<li>安全性 Security</li>
<li>性能 Performance</li>
<li>可伸缩性 Scalability</li>
<li>容错性</li>
</ol>


<p>P51：在软件开发的链条中，链条的强度不是等于最薄弱的环节，而是所有薄弱环节的乘积。</p>

<p>P53：架构应该描述决策的动机，谨防“我们向来这么做”的说法。有个有趣的例子：Beth 想做丈夫 Adbul 家祖传的炖肉。Adbul 说，先撒上胡椒和盐，然后去头去尾，最后放在锅里盖上盖子炖就好了。Beth 就问了，“为什么要去头去尾呢？” Abdul 回答说，我不知道，我一直这么做，这要问我妈。他打电话回家一问，母亲也说不知道，她一直这么做，这个问题要问奶奶。母亲就打了个电话给奶奶，奶奶回答说，“我不知道你为什么要去头去尾，我这么做是因为我的锅太小了装不下”。</p>

<p>P62：选择合适的编程语言很重要。如果C的表达能力是1的话，C++和Java就是2.5。而perl和python却有 6。</p>

<p>P69：“深入一种语言编程”，而不只是“使用一种语言编程”。</p>

<p>P74：设计是一个险恶(Wicked Problem)的问题——只有解决或者部分解决才能被明确的问题。</p>

<p>P75：设计是一个了无章法的过程(Sloppy Process)，优、劣设计之间的差异往往非常微妙。</p>

<p>P77：软件的首要使命是管理复杂度。人们很少把技术原因归结为项目失败的主要因素，项目的失败多数由差强人意的需求、规划和管理导致的。但是，当项目确实由技术因素导致失败时，其原因通常就是失控的复杂度。</p>

<p>P79：拆分实际上是一种“关注点分离”。</p>

<p>高代价、低效率的设计源于三种根源：</p>

<ol>
<li>用复杂的方法解决简单的问题。</li>
<li>用简单但错误的方法解决复杂的问题。</li>
<li>用不恰当的复杂方法解决复杂的问题。</li>
</ol>


<p>P81：</p>

<p>高扇入(high fan-in)：指底层工具类被更多的类使用。</p>

<p>低扇出(low fan-out)：指一个类尽量少的依赖其他的类。</p>

<p>P84：程序调用、组合、继承的依赖程度从轻到中。继承是非常重度的耦合。</p>

<p>P90：</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[缓存不是万灵药]]></title>
    <link href="http://code4craft.github.com/blog/2014/07/01/huan-cun-de-she-ji-ji-qi-ta/"/>
    <updated>2014-07-01T08:00:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/07/01/huan-cun-de-she-ji-ji-qi-ta</id>
    <content type="html"><![CDATA[<p>公司有个很重要的服务，因为数据需求非常杂，所以关联的数据表非常多。而这个服务就承担起提供如此多数据的使命。</p>

<!--more-->


<p>现在的做法是极度依赖缓存的，所以数据都读取出来，打包存到缓存中。一旦失效，一条数据大概会需要上百毫秒去读取，于是我们不得不提供一个预热缓存的程序，定期的去扫描。之前出过一次问题就是缓存失效之后，该服务出现大量超时，乃至线程池跑满，整个服务都不可用。</p>

<p>在我的理解中，缓存是一个提高性能的方案，但是绝对不是万灵药，哪痛贴哪。比如这个服务，有些数据可能只有极少需求方需要，但是之前是统统都读取出来，而我觉得正确的做法可能是理清数据需求，从更细粒度去提供。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分层开发论]]></title>
    <link href="http://code4craft.github.com/blog/2014/06/28/kiss/"/>
    <updated>2014-06-28T22:51:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/06/28/kiss</id>
    <content type="html"><![CDATA[<p>做Java开发的都喜欢分层的思想，似乎层次是越多越好。虽然之间我并不喜欢层次太多，但是也没有太多的理由让我去厌恶它。但是最近在做一些开发，刚好用了两种极端的方式来完成。</p>

<!--more-->


<p>最近在跟同事一起开发项目。两个类似的项目，大致都是一个中间层，从数据库载入一些数据，然后调用另外一个服务。从复杂程度上来说，差距并不大。前一个项目因为之前是他在做这块业务，所以由他主导，结果一开始就分成多层结构，从DAL,DOMAIN,BIZ一层一层往上写起，中间大概有5个对象来完成层级的隔离，转来转去。结果结对编程一个星期，终于弄出雏形。</p>

<p>后来我写另外一个项目，因为开发时间紧，所以理清了业务流程之后，划分为三个阶段，直接分为三个模块，模块内部不分层，从外到内开始写，结果半天就完成了。</p>

<p>到底是分层还是不分层好？分层的意思是隔离变化，核心业务与外部调用分开，降低系统与外部的耦合。但是一般来说，互联网应用内部逻辑相对简单，大部分时间都是在干一些数据相互转换的事情，这种事情你要说跟外部不耦合基本不可能。一般来说，考虑到成本问题，除非需求和数据发生变化，否则外部API变动的可能性极小。这样子耦合的成本并没有那么大。</p>

<p>相反，我觉得系统内部的简单性更加重要。越少开发效率越高，修改越容易，也越不容易出错，分层结构必定是增加了复杂度，但是收获却相对较少。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[没有银弹-谈谈软件设计的几个矛盾(二)]]></title>
    <link href="http://code4craft.github.com/blog/2014/06/17/conflict-cont/"/>
    <updated>2014-06-17T07:49:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/06/17/conflict-cont</id>
    <content type="html"><![CDATA[<h3>1. 关联与冗余</h3>

<p>数据库第三范式种约定，数据没有传递依赖性，但是在互联网应用中，会存在非常多冗余的情况。冗余的目的主要有几个：</p>

<ol>
<li><p>性能</p>

<p> 将所有需要的数据冗余到一起可以提高性能。</p></li>
<li><p>解耦</p>

<p> 一般来说，互联网行业一般都希望一个应用的逻辑尽可能简单，依赖方尽可能的少。冗余数据可以将多个数据源的数据整合到一个数据源，那么应用本身就无需关心这部分逻辑了。</p></li>
<li><p>允许变更</p>

<p> 如果系统A使用了B的数据之后，又有自己独立变更的需要，那么冗余就必不可少了。</p></li>
</ol>


<p>其实从某种意义上，我觉得2比1更重要。而3则是根据需要来决定。从优先级来说是3&gt;2&gt;1。</p>

<p>冗余的坏处有几个：</p>

<ol>
<li><p>有同步的成本</p>

<p> 如果冗余的是一个会发生更新的数据，那么数据同步的成本就不得不考虑了。</p></li>
<li><p>增加整体复杂度</p>

<p> 其实这个是基于1的基础上的。如果只是冗余了数据，后续无需同步，其实系统会相对简单。但是如果有同步的需求，那么可能会有很多个同步的逻辑甚至系统，最后会让整个系统变得复杂和不可控。</p></li>
</ol>


<p>其实第1条的同步机制总归是可以实现的，但是第2条的复杂度才是最需要考虑的地方。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[没有银弹-谈谈软件设计的几个矛盾]]></title>
    <link href="http://code4craft.github.com/blog/2014/06/16/ruan-jian-she-ji-de-ji-ge-mao-dun/"/>
    <updated>2014-06-16T09:30:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/06/16/ruan-jian-she-ji-de-ji-ge-mao-dun</id>
    <content type="html"><![CDATA[<p>最近在做项目的重构和功能改进，设计做了很多，也发生了一些争执。其实总结下来，很多争执的内容其实早就是经典的问题。这些问题没有孰优孰劣，具体采用哪种方案，还得因地制宜，详细分析项目需求和复杂度之后，再做决定。之前很多人都试图只从宏观指导思想来决定设计，最后大家谁也不服谁，所以先把问题确定下来，至少以后思考问题会直接一点。</p>

<!--more-->


<h3>1. 拆分与合并</h3>

<p>从现实世界来说，事物本身就是互相联系的，从这个观点来看，任何对事物的拆分都是不完全正确的。</p>

<p>但是软件开发中，人的理解能力是有限的，而拆分目前看来是降低单个项目复杂度最有效的办法。</p>

<p>拆分有很多级别，最小的可能是拆分代码段，用多个函数代替单个函数，然后是用多个类代替单个类，在Java里面，还可以拆分package，然后拆分jar包，最后拆分成不同的项目。</p>

<p>之前有过很多的争执，关于一个项目要拆还是不拆，以及如何拆。关于这个，我的建议是：</p>

<ol>
<li><p>拆与不拆没有对错</p>

<p> Windows是微内核架构，Linux是单内核架构。微内核意味着内核很小，你可以通过很多个模块去补充它，内核与模块是解耦的。Linux是单内核，就表示所有内核功能会在编译时就确定。可能大家都觉得微内核更好，很多时候它确实更好，但是Linus有个经典的论断：“你不需要管理各个模块，但是你需要处理模块之间的依赖，这个可能比模块本身更复杂”。因为事物本身就是互相联系的，你觉得他们不存在耦合，只是当前使用场景用不到而已。</p></li>
<li><p>系统内部实现对外部透明，保留拆或者不拆的选择权。</p>

<p> 项目自身的复杂度，完全可以靠内部实现解决，对外保持约定好的API，这样对于以后内部的重构，会简单得多。相反，如果暴露了内部实现，那么修改就很困难了。</p></li>
<li><p>对于项目拆分，如果没有充足的理由支持拆分，就不要拆。</p>

<p> 不成熟的拆分，最常见的结果是，随着需求的变化，你不得不打破这种解耦关系，这样反而会带来更多的问题。建议是需求稳定之后，再考虑拆分。</p></li>
<li><p>在系统内部多多进行代码级别的拆分，管理复杂度。</p>

<p> 相比项目的拆分，函数和类级别的拆分成本非常低，值得多用。</p></li>
</ol>


<h3>2. 配置化与灵活性</h3>

<p>一段代码，如果使用一遍，那么我们就直接通过代码实现了。如果我们有几十上百个类似的任务，那么我们就不希望写重复的代码了，我们希望能够通过配置几个不同的参数，从而实现不同的任务。如果任何以后还有不断变化的需求，我们甚至不希望自己写配置，而是有一个运营后台来让需求方(可能是不懂开发的人)直接完成配置。</p>

<p>配置化的开发方式往往对开发者来说有很大的诱惑，从而忽略其中的成本，这个配置最近还有个很火的名字，叫做DSL。但其实配置化和灵活性是矛盾的，配置的表述能力自然要弱于通用语言。当然，也有人尝试使用配置解决所有问题，结果只不过是发明了一门很难用的语言而已。</p>

<p>我自己的框架WebMagic是一个经典的配置与灵活性权衡的例子。WebMagic是一个垂直爬虫框架，爬虫最复杂的是规则的编写，你可以认为这是一个可配置的东西。公司基于它做了一个配置后台，即使是这样，仍然有一些情况，不得不手写Java代码来实现一些功能。</p>

<p>对于这个问题，我的建议是：</p>

<ol>
<li><p>先写代码解决问题，但是提前约定接口。</p>

<p> 第一个阶段，没有谁能预测以后的需求，所以先用你熟悉的代码实现。可以根据你的输入和输出，约定程序级别的接口，相比配置化，这一般来说会容易，如果接口设计得当，也会有具有很大灵活性，以后基本无需更改。</p></li>
<li><p>在有一定积累之后，基于以往的任务做配置化。</p>

<p> 配置的内容是什么呢？首先公共逻辑肯定会在整体框架中，配置的内容应该是不同任务彼此独特的部分。这个配置格式，或者DSL的语法的约定，首先应该基于已有的任务，然后可能考虑一下未来的情况。我是个实践主义者，所以我更多的会参考已有的情况，如果发现这个配置化的框架，对之前的任务都不能满足，那么就需要思考一下它的可行性和必要性了。</p></li>
<li><p>在任何时候都保留能使用代码实现的能力。</p>

<p> 我是个实用主义者。有了配置，如果不提供代码实现的能力，而又有一些复杂的需求，那么就只能扩展配置的能力了。这样只可能会导致这个配置解决框架变得极其庞大和复杂，而相对收益却很低。这个时候，可以通过配置解决大部分问题，然后通过代码解决少量问题，也是不错的选择。</p></li>
</ol>


<h3>3. 总结</h3>

<p>其实还有很多东西没说到，以后补充吧。</p>

<p>总结一句话：软件设计要适应满足需求，同时不断演化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于业务架构的一些思考]]></title>
    <link href="http://code4craft.github.com/blog/2014/06/12/guan-yu-ye-wu-jia-gou-de-yi-xie-si-kao/"/>
    <updated>2014-06-12T07:24:00+08:00</updated>
    <id>http://code4craft.github.com/blog/2014/06/12/guan-yu-ye-wu-jia-gou-de-yi-xie-si-kao</id>
    <content type="html"><![CDATA[<p>最近换了部门，接手了好几个新项目，也进行了一些重构的尝试，总结一些经验。主要针对Web开发领域，算是抛砖引玉了。</p>

<!--more-->


<h2>1. 经历的几种业务架构的方式</h2>

<p>公司是典型的SOA架构，Web层之下就是远程Service。Web层负责调用Service，Service则在内部整合缓存、数据库等内容，实现业务逻辑。</p>

<p>这样的结构没有什么问题，问题就在于Service内部的实现上。即使是Service的一个方法，内部实现也可能很复杂，这就涉及到代码分解的问题。</p>

<p>例如：在一个SNS系统中，我有一个UserService，负责User的CRUD。当然实际逻辑会比较复杂，例如新建User要创建用户，还要初始化积分、等级、收件箱等内容。那么，我该怎么做这件事呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserService</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">addUser</span><span class="o">(</span><span class="n">UserDTO</span> <span class="n">userDTO</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">updateUser</span><span class="o">(</span><span class="n">UserDTO</span> <span class="n">userDTO</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">UserDTO</span> <span class="nf">getUser</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">deleteUser</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>1.1 随意拆分式</h3>

<p>我们之前的结构很随意，大部分代码都直接写在Service的实现类中，Service直接访问Dao实现逻辑。如果过于复杂，则会拆分成一些小的内部Service，并把它们聚合起来。这种方式在业务不复杂的时候，其实工作的还挺好的。</p>

<p><img src="http://static.oschina.net/uploads/space/2014/0612/000228_XQfi_190591.png" alt="架构1" /></p>

<h3>1.2 水平分层式</h3>

<p>新接手的项目，老实说业务会更复杂。之前的做法是将业务分为了dal-数据库访问、domain-领域模型抽象、biz-业务逻辑、service-服务集成四层。例如一个查询数据的操作，可能要经历这么多个分层的流转，才能最终提供外部服务。这样分下来，代码的全复杂度确实也低了不少。</p>

<p>但是这个划分让我接手项目的时候困惑了很久，导致我觉得自己是不是理解能力下降了。后来在着手重构的时候，发现其实很多层次边界根本就很模糊了，甚至连参与维护者也不是很清楚。</p>

<p>过多的分层，会增加坏代码的破坏力，如果边界不是足够清晰，那就不如不分。</p>

<p>我理想的水平分层其实Web-Service-Dao已经足够了，因为他们的边界相对清晰，直接把Dao当做模型也工作得挺好，抽象出Domain来，根据已有的经验略微多余。</p>

<p><img src="http://static.oschina.net/uploads/space/2014/0612/000255_uD3s_190591.png" alt="架构2" /></p>

<h3>1.3 垂直拆分式</h3>

<p>今天在做另一个项目的时候，尝试用一个责任链的方式来做这个事情。采用了垂直拆分的方式，将完成一件事，按照不同的模型，进行了细分，分成多个Processor，接口类似下面这样。Service内部只对这些子Processor做链式调用，它甚至也不知道有多少个Processor。结果这种方法出奇的好，大家发现并行开发很方便，测试也好写了，修改也方便了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Processor</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAdd</span><span class="o">(</span><span class="n">UserDTO</span> <span class="n">userDTO</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onUpdate</span><span class="o">(</span><span class="n">UserDTO</span> <span class="n">userDTO</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDelete</span><span class="o">(</span><span class="n">UserDTO</span> <span class="n">userDTO</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://static.oschina.net/uploads/space/2014/0612/000311_enMh_190591.png" alt="架构3" /></p>

<h2>2. 结论：几个架构的检验标准</h2>

<p>经过多次的折腾，也接手过不少的项目，我得出这么几个结论：</p>

<h3>2.1 一段逻辑，要能让别人轻松的定位到代码在哪里</h3>

<p>这是我参与了很多项目的感受。好的结构并不需要跟踪很多代码层次，才能发现其中的逻辑到底在哪里。相反坏的架构可能有很多层抽象，单个复杂度不高，但是一段逻辑你根本不知道在哪一层。当然也可能是逻辑本身就揉成一坨，也不容易找到想要的东西。</p>

<p>快速的发现相关逻辑，可以减少很多维护成本。</p>

<p>当然，有些架构有学习成本，但是掌握之后，能够满足这个要求，我觉得也可以算是好的架构。</p>

<h3>2.2 Web开发，可扩展性大于可复用性</h3>

<p>根据我一些有限的经验看来，在互联网领域，复用的需求，其实并不如产品需求变更来的迫切。水平分层很大的动机是复用，但是往往内部的复用程度比较有限。而面对需求的变化，水平分层基本上从上到下都进行修改。而合理的垂直拆分可以只修改一个地方，这也是所谓的开闭原则了。</p>
]]></content>
  </entry>
  
</feed>
